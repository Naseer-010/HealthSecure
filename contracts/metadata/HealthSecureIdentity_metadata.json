"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"doctorId\",\"type\":\"string\"}],\"name\":\"DoctorIdLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DoctorVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"healthId\",\"type\":\"string\"}],\"name\":\"HealthIdLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"identityHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum HealthSecureIdentity.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"IdentityRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newProfileCid\",\"type\":\"string\"}],\"name\":\"ProfileUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"doctorIdToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"doctorId\",\"type\":\"string\"}],\"name\":\"getDoctorByDoctorId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getIdentity\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"identityHash\",\"type\":\"bytes32\"},{\"internalType\":\"enum HealthSecureIdentity.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"profileCid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"registeredAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"healthId\",\"type\":\"string\"}],\"name\":\"getPatientByHealthId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"healthIdToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"identities\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"identityHash\",\"type\":\"bytes32\"},{\"internalType\":\"enum HealthSecureIdentity.Role\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"profileCid\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"registeredAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isPatient\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isVerifiedDoctor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identityHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"doctorId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"profileCid\",\"type\":\"string\"}],\"name\":\"registerDoctor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identityHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"healthId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"profileCid\",\"type\":\"string\"}],\"name\":\"registerPatient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newProfileCid\",\"type\":\"string\"}],\"name\":\"updateProfile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"verifyDoctor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Manages blockchain-based user identities for HealthSecure platform\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"getDoctorByDoctorId(string)\":{\"details\":\"Get wallet address by doctor ID\",\"params\":{\"doctorId\":\"Doctor ID to lookup\"}},\"getIdentity(address)\":{\"details\":\"Get identity by wallet address\",\"params\":{\"wallet\":\"Wallet address to lookup\"}},\"getPatientByHealthId(string)\":{\"details\":\"Get wallet address by health ID\",\"params\":{\"healthId\":\"Health ID to lookup\"}},\"isPatient(address)\":{\"details\":\"Check if an address is a patient\",\"params\":{\"wallet\":\"Address to check\"}},\"isVerifiedDoctor(address)\":{\"details\":\"Check if an address is a verified doctor\",\"params\":{\"wallet\":\"Address to check\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"registerDoctor(bytes32,string,string)\":{\"details\":\"Register a new doctor identity\",\"params\":{\"doctorId\":\"Unique doctor ID (e.g., DOC-XXXX-YYYY)\",\"identityHash\":\"SHA256 hash of user credentials\",\"profileCid\":\"IPFS CID for profile metadata\"}},\"registerPatient(bytes32,string,string)\":{\"details\":\"Register a new patient identity\",\"params\":{\"healthId\":\"Unique health ID (e.g., HID-XXXX-YYYY)\",\"identityHash\":\"SHA256 hash of user credentials\",\"profileCid\":\"IPFS CID for profile metadata\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateProfile(string)\":{\"details\":\"Update profile CID\",\"params\":{\"newProfileCid\":\"New IPFS CID for profile\"}},\"verifyDoctor(address)\":{\"details\":\"Verify a doctor (owner only)\",\"params\":{\"doctorAddress\":\"Address of the doctor to verify\"}}},\"title\":\"HealthSecureIdentity\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"This contract stores user identity hashes and links to IPFS profiles\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/HealthSecureIdentity.sol\":\"HealthSecureIdentity\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/HealthSecureIdentity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title HealthSecureIdentity\\n * @dev Manages blockchain-based user identities for HealthSecure platform\\n * @notice This contract stores user identity hashes and links to IPFS profiles\\n */\\ncontract HealthSecureIdentity is Ownable {\\n    \\n    // User roles\\n    enum Role { NONE, PATIENT, DOCTOR }\\n    \\n    // User identity structure\\n    struct Identity {\\n        bytes32 identityHash;       // SHA256 hash of user credentials\\n        Role role;                  // User role (patient or doctor)\\n        string profileCid;          // IPFS CID for profile metadata\\n        bool isVerified;            // Verification status (for doctors)\\n        uint256 registeredAt;       // Registration timestamp\\n        bool exists;                // Whether identity exists\\n    }\\n    \\n    // Mapping from wallet address to identity\\n    mapping(address => Identity) public identities;\\n    \\n    // Mapping from identity hash to wallet address (for reverse lookup)\\n    mapping(bytes32 => address) public hashToAddress;\\n    \\n    // Mapping from health ID to wallet address (for patients)\\n    mapping(string => address) public healthIdToAddress;\\n    \\n    // Mapping from doctor ID to wallet address (for doctors)\\n    mapping(string => address) public doctorIdToAddress;\\n    \\n    // Events\\n    event IdentityRegistered(\\n        address indexed wallet,\\n        bytes32 indexed identityHash,\\n        Role role,\\n        uint256 timestamp\\n    );\\n    \\n    event ProfileUpdated(\\n        address indexed wallet,\\n        string newProfileCid\\n    );\\n    \\n    event DoctorVerified(\\n        address indexed wallet,\\n        uint256 timestamp\\n    );\\n    \\n    event HealthIdLinked(\\n        address indexed wallet,\\n        string healthId\\n    );\\n    \\n    event DoctorIdLinked(\\n        address indexed wallet,\\n        string doctorId\\n    );\\n    \\n    constructor() Ownable(msg.sender) {}\\n    \\n    /**\\n     * @dev Register a new patient identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param healthId Unique health ID (e.g., HID-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerPatient(\\n        bytes32 identityHash,\\n        string calldata healthId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(healthIdToAddress[healthId] == address(0), \\\"Health ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.PATIENT,\\n            profileCid: profileCid,\\n            isVerified: true,  // Patients are auto-verified\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        healthIdToAddress[healthId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.PATIENT, block.timestamp);\\n        emit HealthIdLinked(msg.sender, healthId);\\n    }\\n    \\n    /**\\n     * @dev Register a new doctor identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param doctorId Unique doctor ID (e.g., DOC-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerDoctor(\\n        bytes32 identityHash,\\n        string calldata doctorId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(doctorIdToAddress[doctorId] == address(0), \\\"Doctor ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.DOCTOR,\\n            profileCid: profileCid,\\n            isVerified: false,  // Doctors require verification\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        doctorIdToAddress[doctorId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.DOCTOR, block.timestamp);\\n        emit DoctorIdLinked(msg.sender, doctorId);\\n    }\\n    \\n    /**\\n     * @dev Verify a doctor (owner only)\\n     * @param doctorAddress Address of the doctor to verify\\n     */\\n    function verifyDoctor(address doctorAddress) external onlyOwner {\\n        require(identities[doctorAddress].exists, \\\"Identity not found\\\");\\n        require(identities[doctorAddress].role == Role.DOCTOR, \\\"Not a doctor\\\");\\n        require(!identities[doctorAddress].isVerified, \\\"Already verified\\\");\\n        \\n        identities[doctorAddress].isVerified = true;\\n        \\n        emit DoctorVerified(doctorAddress, block.timestamp);\\n    }\\n    \\n    /**\\n     * @dev Update profile CID\\n     * @param newProfileCid New IPFS CID for profile\\n     */\\n    function updateProfile(string calldata newProfileCid) external {\\n        require(identities[msg.sender].exists, \\\"Identity not registered\\\");\\n        \\n        identities[msg.sender].profileCid = newProfileCid;\\n        \\n        emit ProfileUpdated(msg.sender, newProfileCid);\\n    }\\n    \\n    /**\\n     * @dev Get identity by wallet address\\n     * @param wallet Wallet address to lookup\\n     */\\n    function getIdentity(address wallet) external view returns (\\n        bytes32 identityHash,\\n        Role role,\\n        string memory profileCid,\\n        bool isVerified,\\n        uint256 registeredAt\\n    ) {\\n        Identity memory identity = identities[wallet];\\n        require(identity.exists, \\\"Identity not found\\\");\\n        \\n        return (\\n            identity.identityHash,\\n            identity.role,\\n            identity.profileCid,\\n            identity.isVerified,\\n            identity.registeredAt\\n        );\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a verified doctor\\n     * @param wallet Address to check\\n     */\\n    function isVerifiedDoctor(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.DOCTOR && \\n               identities[wallet].isVerified;\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a patient\\n     * @param wallet Address to check\\n     */\\n    function isPatient(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.PATIENT;\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by health ID\\n     * @param healthId Health ID to lookup\\n     */\\n    function getPatientByHealthId(string calldata healthId) external view returns (address) {\\n        return healthIdToAddress[healthId];\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by doctor ID\\n     * @param doctorId Doctor ID to lookup\\n     */\\n    function getDoctorByDoctorId(string calldata doctorId) external view returns (address) {\\n        return doctorIdToAddress[doctorId];\\n    }\\n}\\n\",\"keccak256\":\"0x482ca07921388f844549245c1e7a262d2bb970b14bd4cfebc89450ea7fee4d9f\",\"license\":\"MIT\"}},\"version\":1}"