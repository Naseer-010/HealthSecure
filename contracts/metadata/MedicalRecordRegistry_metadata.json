"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"recordHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"enum MedicalRecordRegistry.RecordType\",\"name\":\"recordType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RecordCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RecordVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isVisible\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RecordVisibilityChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patientAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"recordHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"},{\"internalType\":\"enum MedicalRecordRegistry.RecordType\",\"name\":\"recordType\",\"type\":\"uint8\"}],\"name\":\"createRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"doctorRecords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"}],\"name\":\"getDoctorRecordIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"}],\"name\":\"getPatientRecordIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"}],\"name\":\"getRecord\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"recordHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"internalType\":\"enum MedicalRecordRegistry.RecordType\",\"name\":\"recordType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isVisible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRecords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"}],\"name\":\"getVisiblePatientRecords\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityContract\",\"outputs\":[{\"internalType\":\"contract HealthSecureIdentity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"patientRecords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recordCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"recordHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"internalType\":\"enum MedicalRecordRegistry.RecordType\",\"name\":\"recordType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isVisible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"}],\"name\":\"toggleVisibility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recordId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"providedHash\",\"type\":\"bytes32\"}],\"name\":\"verifyRecord\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"On-chain registry for medical record hashes and IPFS CIDs\",\"kind\":\"dev\",\"methods\":{\"createRecord(address,bytes32,string,uint8)\":{\"details\":\"Create a new medical record (doctors only)\",\"params\":{\"ipfsCid\":\"IPFS CID for complete record\",\"patientAddress\":\"Patient's wallet address\",\"recordHash\":\"SHA256 hash of record content\",\"recordType\":\"Type of medical record\"}},\"getDoctorRecordIds(address)\":{\"details\":\"Get all record IDs created by a doctor\",\"params\":{\"doctor\":\"Doctor's wallet address\"}},\"getPatientRecordIds(address)\":{\"details\":\"Get all record IDs for a patient\",\"params\":{\"patient\":\"Patient's wallet address\"}},\"getRecord(uint256)\":{\"details\":\"Get record details\",\"params\":{\"recordId\":\"ID of the record\"}},\"getTotalRecords()\":{\"details\":\"Get total record count\"},\"getVisiblePatientRecords(address)\":{\"details\":\"Get visible records for a patient (for doctors searching)\",\"params\":{\"patient\":\"Patient's wallet address\"}},\"toggleVisibility(uint256)\":{\"details\":\"Toggle record visibility (patient only)\",\"params\":{\"recordId\":\"ID of the record to toggle\"}},\"verifyRecord(uint256,bytes32)\":{\"details\":\"Verify a record hash matches stored hash\",\"params\":{\"providedHash\":\"Hash to verify against\",\"recordId\":\"ID of the record to verify\"}}},\"title\":\"MedicalRecordRegistry\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Provides immutable audit trail for medical records\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MedicalRecordRegistry.sol\":\"MedicalRecordRegistry\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/HealthSecureIdentity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title HealthSecureIdentity\\n * @dev Manages blockchain-based user identities for HealthSecure platform\\n * @notice This contract stores user identity hashes and links to IPFS profiles\\n */\\ncontract HealthSecureIdentity is Ownable {\\n    \\n    // User roles\\n    enum Role { NONE, PATIENT, DOCTOR }\\n    \\n    // User identity structure\\n    struct Identity {\\n        bytes32 identityHash;       // SHA256 hash of user credentials\\n        Role role;                  // User role (patient or doctor)\\n        string profileCid;          // IPFS CID for profile metadata\\n        bool isVerified;            // Verification status (for doctors)\\n        uint256 registeredAt;       // Registration timestamp\\n        bool exists;                // Whether identity exists\\n    }\\n    \\n    // Mapping from wallet address to identity\\n    mapping(address => Identity) public identities;\\n    \\n    // Mapping from identity hash to wallet address (for reverse lookup)\\n    mapping(bytes32 => address) public hashToAddress;\\n    \\n    // Mapping from health ID to wallet address (for patients)\\n    mapping(string => address) public healthIdToAddress;\\n    \\n    // Mapping from doctor ID to wallet address (for doctors)\\n    mapping(string => address) public doctorIdToAddress;\\n    \\n    // Events\\n    event IdentityRegistered(\\n        address indexed wallet,\\n        bytes32 indexed identityHash,\\n        Role role,\\n        uint256 timestamp\\n    );\\n    \\n    event ProfileUpdated(\\n        address indexed wallet,\\n        string newProfileCid\\n    );\\n    \\n    event DoctorVerified(\\n        address indexed wallet,\\n        uint256 timestamp\\n    );\\n    \\n    event HealthIdLinked(\\n        address indexed wallet,\\n        string healthId\\n    );\\n    \\n    event DoctorIdLinked(\\n        address indexed wallet,\\n        string doctorId\\n    );\\n    \\n    constructor() Ownable(msg.sender) {}\\n    \\n    /**\\n     * @dev Register a new patient identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param healthId Unique health ID (e.g., HID-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerPatient(\\n        bytes32 identityHash,\\n        string calldata healthId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(healthIdToAddress[healthId] == address(0), \\\"Health ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.PATIENT,\\n            profileCid: profileCid,\\n            isVerified: true,  // Patients are auto-verified\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        healthIdToAddress[healthId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.PATIENT, block.timestamp);\\n        emit HealthIdLinked(msg.sender, healthId);\\n    }\\n    \\n    /**\\n     * @dev Register a new doctor identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param doctorId Unique doctor ID (e.g., DOC-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerDoctor(\\n        bytes32 identityHash,\\n        string calldata doctorId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(doctorIdToAddress[doctorId] == address(0), \\\"Doctor ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.DOCTOR,\\n            profileCid: profileCid,\\n            isVerified: false,  // Doctors require verification\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        doctorIdToAddress[doctorId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.DOCTOR, block.timestamp);\\n        emit DoctorIdLinked(msg.sender, doctorId);\\n    }\\n    \\n    /**\\n     * @dev Verify a doctor (owner only)\\n     * @param doctorAddress Address of the doctor to verify\\n     */\\n    function verifyDoctor(address doctorAddress) external onlyOwner {\\n        require(identities[doctorAddress].exists, \\\"Identity not found\\\");\\n        require(identities[doctorAddress].role == Role.DOCTOR, \\\"Not a doctor\\\");\\n        require(!identities[doctorAddress].isVerified, \\\"Already verified\\\");\\n        \\n        identities[doctorAddress].isVerified = true;\\n        \\n        emit DoctorVerified(doctorAddress, block.timestamp);\\n    }\\n    \\n    /**\\n     * @dev Update profile CID\\n     * @param newProfileCid New IPFS CID for profile\\n     */\\n    function updateProfile(string calldata newProfileCid) external {\\n        require(identities[msg.sender].exists, \\\"Identity not registered\\\");\\n        \\n        identities[msg.sender].profileCid = newProfileCid;\\n        \\n        emit ProfileUpdated(msg.sender, newProfileCid);\\n    }\\n    \\n    /**\\n     * @dev Get identity by wallet address\\n     * @param wallet Wallet address to lookup\\n     */\\n    function getIdentity(address wallet) external view returns (\\n        bytes32 identityHash,\\n        Role role,\\n        string memory profileCid,\\n        bool isVerified,\\n        uint256 registeredAt\\n    ) {\\n        Identity memory identity = identities[wallet];\\n        require(identity.exists, \\\"Identity not found\\\");\\n        \\n        return (\\n            identity.identityHash,\\n            identity.role,\\n            identity.profileCid,\\n            identity.isVerified,\\n            identity.registeredAt\\n        );\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a verified doctor\\n     * @param wallet Address to check\\n     */\\n    function isVerifiedDoctor(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.DOCTOR && \\n               identities[wallet].isVerified;\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a patient\\n     * @param wallet Address to check\\n     */\\n    function isPatient(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.PATIENT;\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by health ID\\n     * @param healthId Health ID to lookup\\n     */\\n    function getPatientByHealthId(string calldata healthId) external view returns (address) {\\n        return healthIdToAddress[healthId];\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by doctor ID\\n     * @param doctorId Doctor ID to lookup\\n     */\\n    function getDoctorByDoctorId(string calldata doctorId) external view returns (address) {\\n        return doctorIdToAddress[doctorId];\\n    }\\n}\\n\",\"keccak256\":\"0x482ca07921388f844549245c1e7a262d2bb970b14bd4cfebc89450ea7fee4d9f\",\"license\":\"MIT\"},\"contracts/MedicalRecordRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./HealthSecureIdentity.sol\\\";\\n\\n/**\\n * @title MedicalRecordRegistry\\n * @dev On-chain registry for medical record hashes and IPFS CIDs\\n * @notice Provides immutable audit trail for medical records\\n */\\ncontract MedicalRecordRegistry {\\n    \\n    // Reference to identity contract\\n    HealthSecureIdentity public identityContract;\\n    \\n    // Record types\\n    enum RecordType { \\n        PRESCRIPTION, \\n        LAB_REPORT, \\n        DIAGNOSIS, \\n        IMAGING, \\n        PROCEDURE, \\n        CONSULTATION, \\n        FOLLOWUP \\n    }\\n    \\n    // Medical record structure (stored on-chain)\\n    struct RecordEntry {\\n        bytes32 recordHash;         // Hash of the record content\\n        string ipfsCid;             // IPFS CID for full record\\n        address patient;            // Patient's wallet address\\n        address doctor;             // Doctor who created the record\\n        RecordType recordType;      // Type of medical record\\n        bool isVisible;             // Visibility status\\n        uint256 createdAt;          // Creation timestamp\\n        bool exists;                // Whether record exists\\n    }\\n    \\n    // Mapping from record ID to record entry\\n    mapping(uint256 => RecordEntry) public records;\\n    \\n    // Current record count (also serves as next ID)\\n    uint256 public recordCount;\\n    \\n    // Mapping from patient address to their record IDs\\n    mapping(address => uint256[]) public patientRecords;\\n    \\n    // Mapping from doctor address to records they created\\n    mapping(address => uint256[]) public doctorRecords;\\n    \\n    // Events\\n    event RecordCreated(\\n        uint256 indexed recordId,\\n        address indexed patient,\\n        address indexed doctor,\\n        bytes32 recordHash,\\n        string ipfsCid,\\n        RecordType recordType,\\n        uint256 timestamp\\n    );\\n    \\n    event RecordVisibilityChanged(\\n        uint256 indexed recordId,\\n        address indexed patient,\\n        bool isVisible,\\n        uint256 timestamp\\n    );\\n    \\n    event RecordVerified(\\n        uint256 indexed recordId,\\n        address indexed verifier,\\n        bool isValid,\\n        uint256 timestamp\\n    );\\n    \\n    constructor(address _identityContract) {\\n        identityContract = HealthSecureIdentity(_identityContract);\\n    }\\n    \\n    /**\\n     * @dev Create a new medical record (doctors only)\\n     * @param patientAddress Patient's wallet address\\n     * @param recordHash SHA256 hash of record content\\n     * @param ipfsCid IPFS CID for complete record\\n     * @param recordType Type of medical record\\n     */\\n    function createRecord(\\n        address patientAddress,\\n        bytes32 recordHash,\\n        string calldata ipfsCid,\\n        RecordType recordType\\n    ) external returns (uint256) {\\n        // Verify caller is a verified doctor\\n        require(\\n            identityContract.isVerifiedDoctor(msg.sender),\\n            \\\"Only verified doctors can create records\\\"\\n        );\\n        \\n        // Verify patient exists\\n        require(\\n            identityContract.isPatient(patientAddress),\\n            \\\"Patient not registered\\\"\\n        );\\n        \\n        // Create record\\n        uint256 recordId = recordCount;\\n        records[recordId] = RecordEntry({\\n            recordHash: recordHash,\\n            ipfsCid: ipfsCid,\\n            patient: patientAddress,\\n            doctor: msg.sender,\\n            recordType: recordType,\\n            isVisible: true,\\n            createdAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        // Add to indexes\\n        patientRecords[patientAddress].push(recordId);\\n        doctorRecords[msg.sender].push(recordId);\\n        \\n        recordCount++;\\n        \\n        emit RecordCreated(\\n            recordId,\\n            patientAddress,\\n            msg.sender,\\n            recordHash,\\n            ipfsCid,\\n            recordType,\\n            block.timestamp\\n        );\\n        \\n        return recordId;\\n    }\\n    \\n    /**\\n     * @dev Toggle record visibility (patient only)\\n     * @param recordId ID of the record to toggle\\n     */\\n    function toggleVisibility(uint256 recordId) external {\\n        require(records[recordId].exists, \\\"Record not found\\\");\\n        require(records[recordId].patient == msg.sender, \\\"Only patient can toggle visibility\\\");\\n        \\n        records[recordId].isVisible = !records[recordId].isVisible;\\n        \\n        emit RecordVisibilityChanged(\\n            recordId,\\n            msg.sender,\\n            records[recordId].isVisible,\\n            block.timestamp\\n        );\\n    }\\n    \\n    /**\\n     * @dev Verify a record hash matches stored hash\\n     * @param recordId ID of the record to verify\\n     * @param providedHash Hash to verify against\\n     */\\n    function verifyRecord(uint256 recordId, bytes32 providedHash) external view returns (bool) {\\n        require(records[recordId].exists, \\\"Record not found\\\");\\n        return records[recordId].recordHash == providedHash;\\n    }\\n    \\n    /**\\n     * @dev Get record details\\n     * @param recordId ID of the record\\n     */\\n    function getRecord(uint256 recordId) external view returns (\\n        bytes32 recordHash,\\n        string memory ipfsCid,\\n        address patient,\\n        address doctor,\\n        RecordType recordType,\\n        bool isVisible,\\n        uint256 createdAt\\n    ) {\\n        require(records[recordId].exists, \\\"Record not found\\\");\\n        RecordEntry memory record = records[recordId];\\n        \\n        // Check access: patient, doctor who created it, or if visible\\n        require(\\n            record.patient == msg.sender || \\n            record.doctor == msg.sender || \\n            record.isVisible,\\n            \\\"Access denied\\\"\\n        );\\n        \\n        return (\\n            record.recordHash,\\n            record.ipfsCid,\\n            record.patient,\\n            record.doctor,\\n            record.recordType,\\n            record.isVisible,\\n            record.createdAt\\n        );\\n    }\\n    \\n    /**\\n     * @dev Get all record IDs for a patient\\n     * @param patient Patient's wallet address\\n     */\\n    function getPatientRecordIds(address patient) external view returns (uint256[] memory) {\\n        return patientRecords[patient];\\n    }\\n    \\n    /**\\n     * @dev Get all record IDs created by a doctor\\n     * @param doctor Doctor's wallet address\\n     */\\n    function getDoctorRecordIds(address doctor) external view returns (uint256[] memory) {\\n        return doctorRecords[doctor];\\n    }\\n    \\n    /**\\n     * @dev Get visible records for a patient (for doctors searching)\\n     * @param patient Patient's wallet address\\n     */\\n    function getVisiblePatientRecords(address patient) external view returns (uint256[] memory) {\\n        uint256[] memory allRecords = patientRecords[patient];\\n        uint256 visibleCount = 0;\\n        \\n        // Count visible records\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            if (records[allRecords[i]].isVisible) {\\n                visibleCount++;\\n            }\\n        }\\n        \\n        // Create array of visible record IDs\\n        uint256[] memory visibleRecords = new uint256[](visibleCount);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < allRecords.length; i++) {\\n            if (records[allRecords[i]].isVisible) {\\n                visibleRecords[index] = allRecords[i];\\n                index++;\\n            }\\n        }\\n        \\n        return visibleRecords;\\n    }\\n    \\n    /**\\n     * @dev Get total record count\\n     */\\n    function getTotalRecords() external view returns (uint256) {\\n        return recordCount;\\n    }\\n}\\n\",\"keccak256\":\"0x18932e8fbeacb1cf4874f8caa5224615a97bd64d639a2f624a2b3bc5e3dbeacd\",\"license\":\"MIT\"}},\"version\":1}"