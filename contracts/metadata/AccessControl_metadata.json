"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"grantedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"AccessGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"revokedAt\",\"type\":\"uint256\"}],\"name\":\"AccessRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"patient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"doctor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"EmergencyAccessGranted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accessGrants\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isGranted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"grantedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"doctorPatients\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"getAccessGrant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isGranted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"grantedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExpired\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"getActivePatientCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"getDoctorPatients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patientAddress\",\"type\":\"address\"}],\"name\":\"getPatientDoctors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"durationSeconds\",\"type\":\"uint256\"}],\"name\":\"grantAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"patientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityContract\",\"outputs\":[{\"internalType\":\"contract HealthSecureIdentity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"patientDoctors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"doctorAddress\",\"type\":\"address\"}],\"name\":\"revokeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Manages patient-doctor access permissions for HealthSecure\",\"kind\":\"dev\",\"methods\":{\"getAccessGrant(address,address)\":{\"details\":\"Get access grant details\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\",\"patientAddress\":\"Patient's wallet address\"}},\"getActivePatientCount(address)\":{\"details\":\"Get count of active access grants for a doctor\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\"}},\"getDoctorPatients(address)\":{\"details\":\"Get all patients who have granted access to a doctor\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\"}},\"getPatientDoctors(address)\":{\"details\":\"Get all doctors a patient has granted access to\",\"params\":{\"patientAddress\":\"Patient's wallet address\"}},\"grantAccess(address,uint256)\":{\"details\":\"Grant access to a doctor\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\",\"durationSeconds\":\"Duration of access (0 = permanent until revoked)\"}},\"hasAccess(address,address)\":{\"details\":\"Check if a doctor has access to a patient's records\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\",\"patientAddress\":\"Patient's wallet address\"}},\"revokeAccess(address)\":{\"details\":\"Revoke access from a doctor\",\"params\":{\"doctorAddress\":\"Doctor's wallet address\"}}},\"title\":\"AccessControl\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Patients can grant/revoke access to specific doctors\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AccessControl.sol\":\"AccessControl\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./HealthSecureIdentity.sol\\\";\\n\\n/**\\n * @title AccessControl\\n * @dev Manages patient-doctor access permissions for HealthSecure\\n * @notice Patients can grant/revoke access to specific doctors\\n */\\ncontract AccessControl {\\n    \\n    // Reference to identity contract\\n    HealthSecureIdentity public identityContract;\\n    \\n    // Access grant structure\\n    struct AccessGrant {\\n        bool isGranted;             // Whether access is currently granted\\n        uint256 grantedAt;          // When access was granted\\n        uint256 expiresAt;          // When access expires (0 = never)\\n        bool exists;                // Whether grant record exists\\n    }\\n    \\n    // Mapping: patient => doctor => access grant\\n    mapping(address => mapping(address => AccessGrant)) public accessGrants;\\n    \\n    // Mapping: patient => list of doctors with access\\n    mapping(address => address[]) public patientDoctors;\\n    \\n    // Mapping: doctor => list of patients who granted access\\n    mapping(address => address[]) public doctorPatients;\\n    \\n    // Events\\n    event AccessGranted(\\n        address indexed patient,\\n        address indexed doctor,\\n        uint256 grantedAt,\\n        uint256 expiresAt\\n    );\\n    \\n    event AccessRevoked(\\n        address indexed patient,\\n        address indexed doctor,\\n        uint256 revokedAt\\n    );\\n    \\n    event EmergencyAccessGranted(\\n        address indexed patient,\\n        address indexed doctor,\\n        string reason,\\n        uint256 timestamp\\n    );\\n    \\n    constructor(address _identityContract) {\\n        identityContract = HealthSecureIdentity(_identityContract);\\n    }\\n    \\n    /**\\n     * @dev Grant access to a doctor\\n     * @param doctorAddress Doctor's wallet address\\n     * @param durationSeconds Duration of access (0 = permanent until revoked)\\n     */\\n    function grantAccess(address doctorAddress, uint256 durationSeconds) external {\\n        // Verify caller is a patient\\n        require(\\n            identityContract.isPatient(msg.sender),\\n            \\\"Only patients can grant access\\\"\\n        );\\n        \\n        // Verify target is a verified doctor\\n        require(\\n            identityContract.isVerifiedDoctor(doctorAddress),\\n            \\\"Target is not a verified doctor\\\"\\n        );\\n        \\n        uint256 expiresAt = durationSeconds > 0 \\n            ? block.timestamp + durationSeconds \\n            : 0;\\n        \\n        // Check if this is a new grant\\n        bool isNewGrant = !accessGrants[msg.sender][doctorAddress].exists;\\n        \\n        accessGrants[msg.sender][doctorAddress] = AccessGrant({\\n            isGranted: true,\\n            grantedAt: block.timestamp,\\n            expiresAt: expiresAt,\\n            exists: true\\n        });\\n        \\n        // Add to lists if new grant\\n        if (isNewGrant) {\\n            patientDoctors[msg.sender].push(doctorAddress);\\n            doctorPatients[doctorAddress].push(msg.sender);\\n        }\\n        \\n        emit AccessGranted(msg.sender, doctorAddress, block.timestamp, expiresAt);\\n    }\\n    \\n    /**\\n     * @dev Revoke access from a doctor\\n     * @param doctorAddress Doctor's wallet address\\n     */\\n    function revokeAccess(address doctorAddress) external {\\n        require(\\n            identityContract.isPatient(msg.sender),\\n            \\\"Only patients can revoke access\\\"\\n        );\\n        \\n        require(\\n            accessGrants[msg.sender][doctorAddress].exists,\\n            \\\"No access grant found\\\"\\n        );\\n        \\n        accessGrants[msg.sender][doctorAddress].isGranted = false;\\n        \\n        emit AccessRevoked(msg.sender, doctorAddress, block.timestamp);\\n    }\\n    \\n    /**\\n     * @dev Check if a doctor has access to a patient's records\\n     * @param patientAddress Patient's wallet address\\n     * @param doctorAddress Doctor's wallet address\\n     */\\n    function hasAccess(address patientAddress, address doctorAddress) external view returns (bool) {\\n        AccessGrant memory grant = accessGrants[patientAddress][doctorAddress];\\n        \\n        if (!grant.exists || !grant.isGranted) {\\n            return false;\\n        }\\n        \\n        // Check if expired\\n        if (grant.expiresAt > 0 && block.timestamp > grant.expiresAt) {\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    /**\\n     * @dev Get access grant details\\n     * @param patientAddress Patient's wallet address\\n     * @param doctorAddress Doctor's wallet address\\n     */\\n    function getAccessGrant(\\n        address patientAddress, \\n        address doctorAddress\\n    ) external view returns (\\n        bool isGranted,\\n        uint256 grantedAt,\\n        uint256 expiresAt,\\n        bool isExpired\\n    ) {\\n        AccessGrant memory grant = accessGrants[patientAddress][doctorAddress];\\n        \\n        bool expired = grant.expiresAt > 0 && block.timestamp > grant.expiresAt;\\n        \\n        return (\\n            grant.isGranted && !expired,\\n            grant.grantedAt,\\n            grant.expiresAt,\\n            expired\\n        );\\n    }\\n    \\n    /**\\n     * @dev Get all doctors a patient has granted access to\\n     * @param patientAddress Patient's wallet address\\n     */\\n    function getPatientDoctors(address patientAddress) external view returns (address[] memory) {\\n        return patientDoctors[patientAddress];\\n    }\\n    \\n    /**\\n     * @dev Get all patients who have granted access to a doctor\\n     * @param doctorAddress Doctor's wallet address\\n     */\\n    function getDoctorPatients(address doctorAddress) external view returns (address[] memory) {\\n        return doctorPatients[doctorAddress];\\n    }\\n    \\n    /**\\n     * @dev Get count of active access grants for a doctor\\n     * @param doctorAddress Doctor's wallet address\\n     */\\n    function getActivePatientCount(address doctorAddress) external view returns (uint256) {\\n        address[] memory patients = doctorPatients[doctorAddress];\\n        uint256 activeCount = 0;\\n        \\n        for (uint256 i = 0; i < patients.length; i++) {\\n            AccessGrant memory grant = accessGrants[patients[i]][doctorAddress];\\n            if (grant.isGranted) {\\n                if (grant.expiresAt == 0 || block.timestamp <= grant.expiresAt) {\\n                    activeCount++;\\n                }\\n            }\\n        }\\n        \\n        return activeCount;\\n    }\\n}\\n\",\"keccak256\":\"0x9a2d332eb1b1a47d1f7c508d4684b9af760fe652f66344688b29c1d808b8f5ac\",\"license\":\"MIT\"},\"contracts/HealthSecureIdentity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title HealthSecureIdentity\\n * @dev Manages blockchain-based user identities for HealthSecure platform\\n * @notice This contract stores user identity hashes and links to IPFS profiles\\n */\\ncontract HealthSecureIdentity is Ownable {\\n    \\n    // User roles\\n    enum Role { NONE, PATIENT, DOCTOR }\\n    \\n    // User identity structure\\n    struct Identity {\\n        bytes32 identityHash;       // SHA256 hash of user credentials\\n        Role role;                  // User role (patient or doctor)\\n        string profileCid;          // IPFS CID for profile metadata\\n        bool isVerified;            // Verification status (for doctors)\\n        uint256 registeredAt;       // Registration timestamp\\n        bool exists;                // Whether identity exists\\n    }\\n    \\n    // Mapping from wallet address to identity\\n    mapping(address => Identity) public identities;\\n    \\n    // Mapping from identity hash to wallet address (for reverse lookup)\\n    mapping(bytes32 => address) public hashToAddress;\\n    \\n    // Mapping from health ID to wallet address (for patients)\\n    mapping(string => address) public healthIdToAddress;\\n    \\n    // Mapping from doctor ID to wallet address (for doctors)\\n    mapping(string => address) public doctorIdToAddress;\\n    \\n    // Events\\n    event IdentityRegistered(\\n        address indexed wallet,\\n        bytes32 indexed identityHash,\\n        Role role,\\n        uint256 timestamp\\n    );\\n    \\n    event ProfileUpdated(\\n        address indexed wallet,\\n        string newProfileCid\\n    );\\n    \\n    event DoctorVerified(\\n        address indexed wallet,\\n        uint256 timestamp\\n    );\\n    \\n    event HealthIdLinked(\\n        address indexed wallet,\\n        string healthId\\n    );\\n    \\n    event DoctorIdLinked(\\n        address indexed wallet,\\n        string doctorId\\n    );\\n    \\n    constructor() Ownable(msg.sender) {}\\n    \\n    /**\\n     * @dev Register a new patient identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param healthId Unique health ID (e.g., HID-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerPatient(\\n        bytes32 identityHash,\\n        string calldata healthId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(healthIdToAddress[healthId] == address(0), \\\"Health ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.PATIENT,\\n            profileCid: profileCid,\\n            isVerified: true,  // Patients are auto-verified\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        healthIdToAddress[healthId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.PATIENT, block.timestamp);\\n        emit HealthIdLinked(msg.sender, healthId);\\n    }\\n    \\n    /**\\n     * @dev Register a new doctor identity\\n     * @param identityHash SHA256 hash of user credentials\\n     * @param doctorId Unique doctor ID (e.g., DOC-XXXX-YYYY)\\n     * @param profileCid IPFS CID for profile metadata\\n     */\\n    function registerDoctor(\\n        bytes32 identityHash,\\n        string calldata doctorId,\\n        string calldata profileCid\\n    ) external {\\n        require(!identities[msg.sender].exists, \\\"Identity already registered\\\");\\n        require(hashToAddress[identityHash] == address(0), \\\"Identity hash already used\\\");\\n        require(doctorIdToAddress[doctorId] == address(0), \\\"Doctor ID already used\\\");\\n        \\n        identities[msg.sender] = Identity({\\n            identityHash: identityHash,\\n            role: Role.DOCTOR,\\n            profileCid: profileCid,\\n            isVerified: false,  // Doctors require verification\\n            registeredAt: block.timestamp,\\n            exists: true\\n        });\\n        \\n        hashToAddress[identityHash] = msg.sender;\\n        doctorIdToAddress[doctorId] = msg.sender;\\n        \\n        emit IdentityRegistered(msg.sender, identityHash, Role.DOCTOR, block.timestamp);\\n        emit DoctorIdLinked(msg.sender, doctorId);\\n    }\\n    \\n    /**\\n     * @dev Verify a doctor (owner only)\\n     * @param doctorAddress Address of the doctor to verify\\n     */\\n    function verifyDoctor(address doctorAddress) external onlyOwner {\\n        require(identities[doctorAddress].exists, \\\"Identity not found\\\");\\n        require(identities[doctorAddress].role == Role.DOCTOR, \\\"Not a doctor\\\");\\n        require(!identities[doctorAddress].isVerified, \\\"Already verified\\\");\\n        \\n        identities[doctorAddress].isVerified = true;\\n        \\n        emit DoctorVerified(doctorAddress, block.timestamp);\\n    }\\n    \\n    /**\\n     * @dev Update profile CID\\n     * @param newProfileCid New IPFS CID for profile\\n     */\\n    function updateProfile(string calldata newProfileCid) external {\\n        require(identities[msg.sender].exists, \\\"Identity not registered\\\");\\n        \\n        identities[msg.sender].profileCid = newProfileCid;\\n        \\n        emit ProfileUpdated(msg.sender, newProfileCid);\\n    }\\n    \\n    /**\\n     * @dev Get identity by wallet address\\n     * @param wallet Wallet address to lookup\\n     */\\n    function getIdentity(address wallet) external view returns (\\n        bytes32 identityHash,\\n        Role role,\\n        string memory profileCid,\\n        bool isVerified,\\n        uint256 registeredAt\\n    ) {\\n        Identity memory identity = identities[wallet];\\n        require(identity.exists, \\\"Identity not found\\\");\\n        \\n        return (\\n            identity.identityHash,\\n            identity.role,\\n            identity.profileCid,\\n            identity.isVerified,\\n            identity.registeredAt\\n        );\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a verified doctor\\n     * @param wallet Address to check\\n     */\\n    function isVerifiedDoctor(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.DOCTOR && \\n               identities[wallet].isVerified;\\n    }\\n    \\n    /**\\n     * @dev Check if an address is a patient\\n     * @param wallet Address to check\\n     */\\n    function isPatient(address wallet) external view returns (bool) {\\n        return identities[wallet].exists && \\n               identities[wallet].role == Role.PATIENT;\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by health ID\\n     * @param healthId Health ID to lookup\\n     */\\n    function getPatientByHealthId(string calldata healthId) external view returns (address) {\\n        return healthIdToAddress[healthId];\\n    }\\n    \\n    /**\\n     * @dev Get wallet address by doctor ID\\n     * @param doctorId Doctor ID to lookup\\n     */\\n    function getDoctorByDoctorId(string calldata doctorId) external view returns (address) {\\n        return doctorIdToAddress[doctorId];\\n    }\\n}\\n\",\"keccak256\":\"0x482ca07921388f844549245c1e7a262d2bb970b14bd4cfebc89450ea7fee4d9f\",\"license\":\"MIT\"}},\"version\":1}"